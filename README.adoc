:doctype: book
:toc: left
:toclevels: 3
:toc-position: left
:numbered:

= Spring Boot Testsuite

== Instructions

The command to be used to execute an Integration Test is :

----
mvn clean verify -Popenshift -Plogin -Dopenshift.user=admin \
                                     -Dopenshift.password=admin \
                                     -Dopenshift.api=$(minishift console --url) \
                                     -Dopenshift.namespace=test
----

== Next use cases

* Server-side load balancing (Kube/OpeShift).
* Kubernetes/DNS for service registration/discovery (+ ribbon backed by Kube with one IP?)
  If multiple endpoints are registered, they will be used for loadbalancing by ribbon (https://github.com/fabric8io/spring-cloud-kubernetes#ribbon-discovery-in-kubernetes)
* Kubernetes ConfigMap for configuration
* Health Check (OpenShift+Spring Boot Actuator)
* Hystrix + Turbine Server to stream info reported by the Services Circuit Checked (= Hystrix Circuit Breaker pattern)
* Zipkin (https://github.com/fabric8io/kubernetes-zipkin) till Hawkular (APM) + CloudForms are ready / https://cloud.spring.io/spring-cloud-sleuth/
* Logging (EFK)
* Zuul --> On OpenShift : APi Manager + Apiman Gateway should be the way to go

== REST Service with Apache Tomcat

* Component : https://github.com/spring-projects/spring-boot/tree/master/spring-boot-starters/spring-boot-starter-web[Spring Boot Starter Web], https://github.com/spring-projects/spring-boot/tree/master/spring-boot-starters/spring-boot-starter-tomcat[Spring Boot Starter Web Tomcat]
* Framework : Spring Web, Spring Web MVC
* Container : Apache Tomcat

**Description**

A REST endpoint is exposed by Spring Boot using as Java Web Container Apache Tomcat. The REST endpoint `/greeting` returns a message to say hello world with an id which is increment
for each call.

----
http http://localhost:8080/greeting
HTTP/1.1 200 
Content-Type: application/json;charset=UTF-8
Date: Thu, 23 Feb 2017 08:11:08 GMT
Transfer-Encoding: chunked

{
    "content": "Hello, World!",
    "id": 1
}
----

== REST Service using Apache CXF

* Component : https://github.com/spring-projects/spring-boot/tree/master/spring-boot-starters/spring-boot-starter-tomcat[Spring Boot Starter Web Tomcat]
* Framework : Apache CXF - 3.1.10
* Container : Apache Tomcat

This use case is based on the same logic as `REST Service with Apache Tomcat` but it uses as starter `Spring Boot Starter - Apache CXF`. To let
Apache CXF to discover the services and register the REST application, the property `cxf -> jaxrs` has been added within the `application.properties`
file in order to tell to the framework to discover and register the REST endpoints

----
cxf:
  jaxrs:
    component-scan: true
----

== Access your data using JPA

* Component : https://github.com/spring-projects/spring-boot/tree/master/spring-boot-starters/spring-boot-starter-data-jpa[Spring Boot Starter Data JPA]
* Framework : Hibernate

**Description**

The goal of this use case is to setup a CRUD service talking to a H2 Database where the model is defined according to a https://github.com/redhat-microservices/lab_swarm-openshift/blob/master/solution/cdservice/src/main/java/org/cdservice/model/Catalog.java[CD Catalog entity].
At run time, an in memory H2 database is created, some records imported using an import.sql file. The definition of the datasource is defined within the `application.proerpties or application.yml` file.
A Service class will contain the CRUD methods. No transaction support is required.

References:

- https://spring.io/guides/gs/accessing-data-jpa[Spring How To guide]
- https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-sql.html[Spring Boot doc]
- http://blog.anthavio.net/2016/03/fun-with-spring-boot-auto-configuration.html[DataSource configuration]
